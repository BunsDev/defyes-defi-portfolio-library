"""
Spark protocol (by default in Ethereum mainnet)

Mainnet Addresses https://docs.sparkprotocol.io/developers/deployed-contracts/mainnet-addresses
"""

from decimal import Decimal
from typing import Iterator, NamedTuple

from defyes.constants import Chain
from defyes.types import Addr, Token, TokenAmount

from .autogenerated import ProtocolDataProvider


class ReserveTokens(NamedTuple):
    sp: Token
    stable_debt: Token
    variable_debt: Token


class UserReserveData(NamedTuple):
    sp: int
    stable_debt: int
    variable_debt: int
    principal_stable_debt: int
    scaled_variable_debt: int
    stable_borrow_rate: int
    reserve_liquidity_rate: int
    timestamp: int
    is_collateral: bool


class ProtocolDataProvider(ProtocolDataProvider):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: Addr("0xFc21d6d146E6086B8359705C8b28512a983db0cb"),
    }

    @property
    def assets_with_reserve_tokens(self) -> Iterator[tuple[Token, Token]]:
        for _, main_token in self.all_reserves_tokens:
            tokens = self.get_reserve_tokens_addresses(main_token)
            yield main_token, tokens

    @property
    def all_reserves_tokens(self) -> Iterator[tuple[str, Token]]:
        for symbol, addr in self.get_all_reserves_tokens:
            yield symbol, Token.get_instance(addr, self.blockchain)

    def get_reserve_tokens_addresses(self, asset_addr: str) -> ReserveTokens:
        addresses = super().get_reserve_tokens_addresses(asset_addr)
        return ReserveTokens(*(Token.get_instance(addr, self.blockchain) for addr in addresses))

    @property
    def last_block_id(self):
        return self.contract.w3.eth.block_number

    @property
    def block_id(self):
        return self.block if isinstance(self.block, int) else self.last_block_id

    def underlying_all(self, wallet: Addr):
        wallet = Addr(wallet)
        return {
            "blockchain": self.blockchain,
            "block_id": self.block_id,
            "protocol": "Spark",
            "version": 0,
            "wallet": wallet,
            "positions": dict(self.positions(wallet)),
        }

    def positions(self, wallet: Addr) -> Iterator[tuple[Addr, dict]]:
        for asset, tokens in self.assets_with_reserve_tokens:
            user_reserve_data = UserReserveData(*self.get_user_reserve_data(asset, wallet))

            def holdings():
                for int_amount, token in zip(user_reserve_data[:3], tokens):
                    if int_amount != 0:
                        yield TokenAmount(int_amount, token)

            holdings = list(holdings())
            if holdings:
                int_amount = user_reserve_data.sp - user_reserve_data.stable_debt - user_reserve_data.variable_debt
                position = {
                    "holdings": holdings,
                    "underlying": TokenAmount(int_amount, asset),
                }
                yield asset, position


def underlying_all(wallet: Addr, block: int | str, chain: Chain, decimal: bool = True) -> dict:
    ret = ProtocolDataProvider(chain, block).underlying_all(wallet)

    def to_value(token_amount):
        return Decimal(str(token_amount)) if decimal else int(token_amount)

    def to_dict(token_amount):
        return {"balance": to_value(token_amount), "address": str(token_amount.token)}

    positions = ret["positions"]

    ret["positions"] = {
        str(asset): {
            "holdings": [to_dict(token_amount) for token_amount in position["holdings"]],
            "underlying": to_value(position["underlying"]),
        }
        for asset, position in positions.items()
    }
    return ret
