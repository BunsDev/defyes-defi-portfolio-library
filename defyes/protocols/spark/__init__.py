"""
Spark protocol (by default in Ethereum mainnet)

Mainnet Addresses https://docs.sparkprotocol.io/developers/deployed-contracts/mainnet-addresses
"""

from collections import namedtuple
from functools import cached_property

from defyes.constants import Chain
from defyes.node import get_node
from defyes.types import Addr, Token, TokenAmount

from .autogenerated import ProtocolDataProvider


class ProtocolDataProvider(ProtocolDataProvider):
    default_addresses: dict[str, str] = {
        Chain.ETHEREUM: "0xFc21d6d146E6086B8359705C8b28512a983db0cb",
    }

    @property
    def reserve_tokens_addresses(self):
        for name, addr in self.get_all_reserves_tokens:
            token = Token(addr, name)
            reserve_addrs = (Addr(a) for a in self.get_reserve_tokens_addresses(addr)[:3])
            reserve = Reserve(*reserve_addrs)
            yield token, reserve

    @cached_property
    def web3(self):
        return get_node(self.blockchain, self.block)

    def underlying_all(self, wallet: Addr):
        block_id = self.block if isinstance(self.block, int) else self.web3.eth.block_number
        wallet = Addr(wallet)
        return {
            "blockchain": self.blockchain,
            "block": block_id,
            "protocol": "Spark",
            "positions_key": "underlying_token_address",
            "version": 0,
            "wallet": wallet,
            "positions": dict(self.positions(wallet)),
        }

    def positions(self, wallet: Addr):
        web3 = self.web3
        for token, addr in self.reserve_tokens_addresses:
            sp_balance, stable_debt, variable_debt, *_ = self.get_user_reserve_data(str(token), wallet)
            if (sp_balance, stable_debt, variable_debt) == (0, 0, 0):
                continue
            position = {
                "holdings": [
                    {
                        # Should we include zero balances?
                        "address": addr.interest_bearing,
                        "balance": TokenAmount(sp_balance, addr.interet_bearing, web3),
                    },
                    {
                        "address": addr.stable_debt,
                        "balance": TokenAmount(stable_debt, addr.stable_debt, web3),
                    },
                    {
                        "address": addr.variable_debt,
                        "balance": TokenAmount(variable_debt, addr.variable_debt, web3),
                    },
                ],
                "underlying": [
                    {
                        "address": str(token),
                        "balance": TokenAmount(sp_balance - stable_debt - variable_debt, addr.variable_debt, web3),
                    }
                ],
            }
            yield token, position


Reserve = namedtuple("Reserve", "interest_bearing stable_debt variable_debt")


def underlying_all(wallet: Addr, block: int | str, chain: Chain) -> dict:
    return ProtocolDataProvider(chain, block).underlying_all(wallet)
