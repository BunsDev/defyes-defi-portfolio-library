"""
Autogenerated module. Don't change it manualy. Instead, import its classes into __init__.py or even derive them adding
extra methds.

# Inside __init__.py

from .autogenerated import ProtocolDataProvider

# Optionally
class ProtocolDataProvider(ProtocolDataProvider):
    ...
"""
from web3 import Web3

from defyes.generator import load_abi
from defyes.node import get_node


class ProtocolDataProvider:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = Web3.to_checksum_address(address)
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError("No default_addresses defined when trying to guess the address.") from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain, block)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, "protocol_data_provider.json"))

    @property
    def addresses_provider(self) -> str:
        return self.contract.functions.ADDRESSES_PROVIDER().call(block_identifier=self.block)

    def get_sp_token_total_supply(self, asset: str) -> int:
        return self.contract.functions.getSpTokenTotalSupply(asset).call(block_identifier=self.block)

    @property
    def get_all_sp_tokens(self) -> list[tuple]:
        return self.contract.functions.getAllSpTokens().call(block_identifier=self.block)

    @property
    def get_all_reserves_tokens(self) -> list[tuple]:
        return self.contract.functions.getAllReservesTokens().call(block_identifier=self.block)

    def get_debt_ceiling(self, asset: str) -> int:
        return self.contract.functions.getDebtCeiling(asset).call(block_identifier=self.block)

    @property
    def get_debt_ceiling_decimals(self) -> int:
        return self.contract.functions.getDebtCeilingDecimals().call(block_identifier=self.block)

    def get_interest_rate_strategy_address(self, asset: str) -> str:
        return self.contract.functions.getInterestRateStrategyAddress(asset).call(block_identifier=self.block)

    def get_liquidation_protocol_fee(self, asset: str) -> int:
        return self.contract.functions.getLiquidationProtocolFee(asset).call(block_identifier=self.block)

    def get_paused(self, asset: str) -> bool:
        return self.contract.functions.getPaused(asset).call(block_identifier=self.block)

    def get_reserve_caps(self, asset: str) -> tuple[int, int]:
        """
        Output: borrowCap, supplyCap
        """
        return self.contract.functions.getReserveCaps(asset).call(block_identifier=self.block)

    def get_reserve_configuration_data(
        self, asset: str
    ) -> tuple[int, int, int, int, int, bool, bool, bool, bool, bool]:
        """
        Output: decimals, ltv, liquidationThreshold, liquidationBonus,
            reserveFactor, usageAsCollateralEnabled, borrowingEnabled,
            stableBorrowRateEnabled, isActive, isFrozen
        """
        return self.contract.functions.getReserveConfigurationData(asset).call(block_identifier=self.block)

    def get_reserve_data(self, asset: str) -> tuple[int, int, int, int, int, int, int, int, int, int, int, int]:
        """
        Output: unbacked, accruedToTreasuryScaled, totalSpToken,
            totalStableDebt, totalVariableDebt, liquidityRate, variableBorrowRate,
            stableBorrowRate, averageStableBorrowRate, liquidityIndex,
            variableBorrowIndex, lastUpdateTimestamp
        """
        return self.contract.functions.getReserveData(asset).call(block_identifier=self.block)

    def get_reserve_e_mode_category(self, asset: str) -> int:
        return self.contract.functions.getReserveEModeCategory(asset).call(block_identifier=self.block)

    def get_reserve_tokens_addresses(self, asset: str) -> tuple[str, str, str]:
        """
        Output: spTokenAddress, stableDebtTokenAddress,
            variableDebtTokenAddress
        """
        return self.contract.functions.getReserveTokensAddresses(asset).call(block_identifier=self.block)

    def get_siloed_borrowing(self, asset: str) -> bool:
        return self.contract.functions.getSiloedBorrowing(asset).call(block_identifier=self.block)

    def get_total_debt(self, asset: str) -> int:
        return self.contract.functions.getTotalDebt(asset).call(block_identifier=self.block)

    def get_unbacked_mint_cap(self, asset: str) -> int:
        return self.contract.functions.getUnbackedMintCap(asset).call(block_identifier=self.block)

    def get_user_reserve_data(self, asset: str, user: str) -> tuple[int, int, int, int, int, int, int, int, bool]:
        """
        Output: currentSpTokenBalance, currentStableDebt,
            currentVariableDebt, principalStableDebt, scaledVariableDebt,
            stableBorrowRate, liquidityRate, stableRateLastUpdated,
            usageAsCollateralEnabled
        """
        return self.contract.functions.getUserReserveData(asset, user).call(block_identifier=self.block)
