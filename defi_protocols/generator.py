import itertools
import json
import re
from pathlib import Path

import black
import isort


def get_module_path(module_file):
    return Path(module_file).resolve().parent


current_module_path = get_module_path(__file__)


def load_abi(module_file_path, abi_filename):
    protocol_path = get_module_path(module_file_path)
    path = protocol_path / "abis" / abi_filename
    with open(path) as f:
        return f.read()


def snake_to_camel(snake_case):
    words = snake_case.split("_")
    camel_case = "".join(word.title() for word in words)
    return camel_case


def camel_to_snake(camel_case):
    s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", camel_case)
    return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()


def args_name_gen(used_names: set, start: int = 0):
    used_names_ = set(used_names)
    for index in itertools.count(start=start):
        name = f"arg{index}"
        while name in used_names_:
            name += "_"
        yield name
        used_names_.add(name)


def generate_methods_from_abi(abi_path, const_call_methods=[]):
    TYPE_CONVERSION = {
        "uint8": "int",
        "uint64": "int",
        "uint256": "int",
        "uint64[]": "list[int]",
        "uint256[]": "list[int]",
        "address": "str",
        "address[]": "list[str]",
        "string": "str",
        "bytes32": "bytes",
    }

    with open(abi_path) as f:
        abi_list = json.load(f)

    methods = []
    for item in abi_list:
        method_name = item["name"]
        method_name_snake = camel_to_snake(method_name)
        method_str = ""

        awesome_names = args_name_gen(used_names=set(arg.get("name", "") for arg in item["inputs"]))
        args = []
        args_names = []
        for arg, auto_name in zip(item["inputs"], awesome_names):
            arg_name = camel_to_snake(arg.get("name") or auto_name)
            arg_type = TYPE_CONVERSION.get(arg["type"], arg["type"])
            args.append(f"{arg_name}: {arg_type}")
            args_names.append(arg_name)

        if args:
            args_str = ", " + ", ".join(args)
            args_names = ", ".join(args_names)
        else:
            method_str += "    @property\n"
            args_str = ""
            args_names = ""

        outputs = item.get("outputs", [])
        if outputs:
            return_str = ""
            return_comment = ""
            return_types = []
            return_names = []
            for output in outputs:
                output_type = output.get("type", "")
                output_name = output.get("name", "")
                try:
                    return_type = TYPE_CONVERSION[output_type]
                except KeyError:
                    return_type = output_type
                return_types.append(return_type)
                return_names.append(output_name)

            if len(return_types) == 1:
                return_str = f" -> {return_types[0]}"
            else:
                return_str = f' -> tuple[{", ".join(return_types)}]'
                return_comment = f'        # Output: {", ".join(return_names)}\n'

        if method_name in const_call_methods:
            ret = f"        return const_call(self.contract.functions.{method_name}({args_names}))\n"
        else:
            ret = f"        return self.contract.functions.{method_name}({args_names}).call(block_identifier=self.block)\n"
        method_str += f"    def {method_name_snake}(self{args_str}){return_str}:\n"
        method_str += return_comment if return_comment else ""
        method_str += ret

        methods.append(method_str)

    return "\n".join(methods)


header_template = """
'''
Autogenerated module. Don't change it manualy. Instead, import its classes into __init__.py or even derive them adding
extra methds.

# Inside __init__.py

from .autogenerated import %(classes)s

# Optionally
class %(first_class)s(%(first_class)s):
    ...
'''
from defi_protocols.cache import const_call
from defi_protocols.functions import get_node
from defi_protocols.generator import load_abi
"""

contract_class_template = """

class %(name)s:
    default_addresses: dict[str, str]

    def __init__(self, blockchain: str, block: int, address: str | None = None) -> None:
        self.block = block
        self.blockchain = blockchain
        if address:
            self.address = address
        else:
            try:
                self.address = self.default_addresses[blockchain]
            except AttributeError as e:
                raise ValueError(
                    "No default_addresses defined when trying to guess the address."
                ) from e
            except KeyError as e:
                raise ValueError(
                    f"{blockchain!r} not defined in default_addresses when trying to guess the address."
                ) from e
        node = get_node(blockchain, block)
        self.contract = node.eth.contract(address=self.address, abi=load_abi(__file__, %(abi)r))\n
"""


def generate_contract_class(class_name, abi_path, const_call_methods=[]):
    abi_filename = abi_path.name
    result = contract_class_template % dict(name=class_name, abi=abi_filename)
    result += generate_methods_from_abi(abi_path, const_call_methods)
    return result


def generate_classes():
    setup_paths = current_module_path.glob("**/autogen_config.json")
    for setup_path in setup_paths:
        with open(setup_path) as f:
            abis_to_process = json.load(f)

        protocol_path = setup_path.parent
        autogenerated_module_path = protocol_path / "autogenerated.py"

        content = ""
        classes_name = []
        for abi_name, config in abis_to_process.items():
            abi_path = protocol_path / "abis" / f"{abi_name}.json"
            class_name = snake_to_camel(abi_name)
            classes_name.append(class_name)
            content += generate_contract_class(class_name, abi_path, config["const_call"])

        if not content:
            continue

        content = isort.code(content)
        content = black.format_file_contents(content, fast=True, mode=black.FileMode())
        with open(autogenerated_module_path, "w") as f:
            f.write(header_template % dict(classes=", ".join(classes_name), first_class=classes_name[0]))
            f.write(content)


if __name__ == "__main__":
    generate_classes()
