"""
Autogenerated module. Don't change it manualy. Instead, import its classes from __init__.py and derive them there into
concrete clases defining BLOCKCHAIN and ADDR.

# Inside __init__.py

from . import abstract

class SomeContract(abstract.SomeContract):
    ...
"""
from defi_protocols.cache import const_call
from defi_protocols.functions import get_node
from defi_protocols.generator import load_abi


class Oracle:
    BLOCKCHAIN: str
    ADDR: str

    def __init__(self, block) -> None:
        node = get_node(self.BLOCKCHAIN, block)
        self.block = block
        self.contract = node.eth.contract(
            address=self.ADDR, abi=load_abi(__file__, "oracle.json")
        )

    @property
    def description(self) -> str:
        return const_call(self.contract.functions.DESCRIPTION())

    @property
    def read(self) -> int:
        return self.contract.functions.read().call(block_identifier=self.block)


class Treasury:
    BLOCKCHAIN: str
    ADDR: str

    def __init__(self, block) -> None:
        node = get_node(self.BLOCKCHAIN, block)
        self.block = block
        self.contract = node.eth.contract(
            address=self.ADDR, abi=load_abi(__file__, "treasury.json")
        )

    @property
    def stablecoin(self) -> str:
        return const_call(self.contract.functions.stablecoin())

    def vault_manager_list(self, arg0: int) -> str:
        return self.contract.functions.vaultManagerList(arg0).call(
            block_identifier=self.block
        )

    def is_vault_manager(self, _vault_manager: str) -> bool:
        return self.contract.functions.isVaultManager(_vault_manager).call(
            block_identifier=self.block
        )


class VaultManager:
    BLOCKCHAIN: str
    ADDR: str

    def __init__(self, block) -> None:
        node = get_node(self.BLOCKCHAIN, block)
        self.block = block
        self.contract = node.eth.contract(
            address=self.ADDR, abi=load_abi(__file__, "vault_manager.json")
        )

    def balance_of(self, owner: str) -> int:
        return self.contract.functions.balanceOf(owner).call(
            block_identifier=self.block
        )

    @property
    def vault_id_count(self) -> int:
        return self.contract.functions.vaultIDCount().call(block_identifier=self.block)

    def owner_of(self, vault_id: int) -> str:
        return self.contract.functions.ownerOf(vault_id).call(
            block_identifier=self.block
        )

    @property
    def oracle(self) -> str:
        return const_call(self.contract.functions.oracle())

    @property
    def collateral_factor(self) -> int:
        return self.contract.functions.collateralFactor().call(
            block_identifier=self.block
        )

    @property
    def base_interest(self) -> int:
        return const_call(self.contract.functions.BASE_INTEREST())

    @property
    def base_params(self) -> int:
        return const_call(self.contract.functions.BASE_PARAMS())

    @property
    def collateral(self) -> str:
        return const_call(self.contract.functions.collateral())

    def get_vault_debt(self, vault_id: int) -> int:
        return self.contract.functions.getVaultDebt(vault_id).call(
            block_identifier=self.block
        )

    def vault_data(self, arg0: int) -> tuple[int, int]:
        # Output: collateralAmount, normalizedDebt
        return self.contract.functions.vaultData(arg0).call(block_identifier=self.block)

    @property
    def stablecoin(self) -> str:
        return const_call(self.contract.functions.stablecoin())

    @property
    def interest_rate(self) -> int:
        return self.contract.functions.interestRate().call(block_identifier=self.block)
