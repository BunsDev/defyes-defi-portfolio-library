"""
Spark protocol (by default in Ethereum mainnet)

Mainnet Addresses https://docs.sparkprotocol.io/developers/deployed-contracts/mainnet-addresses
"""

from decimal import Decimal, DivisionByZero, InvalidOperation
from functools import cached_property
from typing import Iterator, NamedTuple

from defi_protocols.constants import ETHEREUM
from defyes.prices import Chainlink as chainlink
from future_defyes.types import Addr, Token, TokenAmount

from .autogenerated import Oracle, Pool, PoolAddressesProvider, ProtocolDataProvider


class ReserveTokensAddresses(NamedTuple):
    sp: Addr
    stable_debt: Addr
    variable_debt: Addr


class UserReserveData(NamedTuple):
    sp: int
    stable_debt: int
    variable_debt: int
    principal_stable_debt: int
    scaled_variable_debt: int
    stable_borrow_rate: int
    reserve_liquidity_rate: int
    timestamp: int
    is_collateral: bool


class UserAccountData(NamedTuple):
    total_collateral_base: int
    total_debt_base: int
    available_borrows_base: int
    current_liquidation_threshold: int
    ltv: int
    health_factor: int

    @property
    def collateral_ratio(self):
        try:
            return 100 * Decimal(self.total_collateral_base) / self.total_debt_base
        except DivisionByZero:
            return Decimal("infinity")
        except InvalidOperation:
            return Decimal("nan")

    @property
    def liquidation_ratio(self):
        try:
            return 1000000 / Decimal(self.current_liquidation_threshold)
        except DivisionByZero:
            return Decimal("infinity")


class Pool(Pool):
    def user_account_data(self, user: str) -> UserAccountData:
        return UserAccountData(*self.get_user_account_data(user))


class PoolAddressesProvider(PoolAddressesProvider):
    default_addresses: dict[str, str] = {
        ETHEREUM: Addr("0x02C3eA4e34C0cBd694D2adFa2c690EECbC1793eE"),
    }

    @cached_property
    def pool_contract(self):
        return Pool(self.blockchain, self.block, address=self.get_pool)

    @cached_property
    def price_oracle_contract(self):
        return Oracle(self.blockchain, self.block, address=self.get_price_oracle)


class ProtocolDataProvider(ProtocolDataProvider):
    default_addresses: dict[str, str] = {
        ETHEREUM: Addr("0xFc21d6d146E6086B8359705C8b28512a983db0cb"),
    }

    @property
    def assets_with_reserve_tokens(self):
        for asset_name, asset_addr in self.get_all_reserves_tokens:
            asset = Token(asset_addr, asset_name)
            tokens = self.get_reserve_tokens_addresses(asset_addr)
            yield asset, ReserveTokensAddresses(*tokens)

    @property
    def web3(self):
        return self.contract.w3

    @property
    def last_block_id(self):
        return self.web3.eth.block_number

    @property
    def block_id(self):
        return self.block if isinstance(self.block, int) else self.last_block_id

    def underlying_all(self, wallet: Addr):
        wallet = Addr(wallet)
        return {
            "blockchain": self.blockchain,
            "block_id": self.block_id,
            "protocol": "Spark",
            "version": 0,
            "wallet": wallet,
            "positions": dict(self.positions(wallet)),
        }

    def positions(self, wallet: Addr) -> Iterator[tuple[Token, dict]]:
        web3 = self.web3
        for asset, tokens in self.assets_with_reserve_tokens:
            ur = UserReserveData(*self.get_user_reserve_data(asset, wallet))

            def holdings():
                for amount, (kind, addr) in zip(ur[:3], tokens._asdict().items()):
                    if amount != 0:
                        yield f"{kind}_{asset.label}", TokenAmount(amount, addr, web3)

            holdings = dict(holdings())
            if holdings:
                position = {
                    "holdings": holdings,
                    "underlying": TokenAmount(ur.sp - ur.stable_debt - ur.variable_debt, str(asset), web3),
                }
                yield asset, position


class ReserveTokensAddresses(NamedTuple):
    sp: Addr
    stable_debt: Addr
    variable_debt: Addr


class UserReserveData(NamedTuple):
    sp: int
    stable_debt: int
    variable_debt: int
    principal_stable_debt: int
    scaled_variable_debt: int
    stable_borrow_rate: int
    reserve_liquidity_rate: int
    timestamp: int
    is_collateral: bool


def underlying_all(wallet: Addr, block: int | str, chain: str, decimals: bool = True) -> dict:
    ret = ProtocolDataProvider(chain, block).underlying_all(wallet)

    def to_value(token_amount):
        return Decimal(str(token_amount)) if decimals else int(token_amount)

    def to_dict(token_amount):
        return {"balance": to_value(token_amount), "address": token_amount.addr}

    positions = ret["positions"]

    ret["positions"] = {
        str(asset): {
            "holdings": [to_dict(token_amount) for token_amount in position["holdings"].values()],
            "underlying": to_value(position["underlying"]),
        }
        for asset, position in positions.items()
    }
    ret["decimals"] = decimals
    return ret


# TODO: This function should be removed and its functionality added as financial metrics in the underlying_all function
def get_data(wallet: Addr, block: int | str, chain: str, decimals: bool = True) -> dict:
    def to_value(token_amount):
        return Decimal(str(token_amount)) if decimals else int(token_amount)

    wallet = Addr(wallet)
    pap = PoolAddressesProvider(chain, block)

    user_account_data = pap.pool_contract.user_account_data(wallet)
    ret = {
        "collateral_ratio": user_account_data.collateral_ratio,
        "liquidation_ratio": user_account_data.liquidation_ratio,
        "native_token_price_usd": chainlink.get_native_token_price(pap.contract.w3, block, chain, decimals=True),
        "collaterals": (collaterals := []),
        "debts": (debts := []),
    }

    if True:
        currency_unit = Decimal(pap.price_oracle_contract.base_currency_unit)
        for token, position in ProtocolDataProvider(chain, block).positions(wallet):
            asset = {
                "token_address": str(token),
                "token_amount": abs(underlying := to_value(position["underlying"])),
                "token_price_usd": pap.price_oracle_contract.get_asset_price(token) / currency_unit,
                "token_symbol": token.label,
            }
            if underlying < 0:
                debts.append(asset)
            else:
                collaterals.append(asset)
    return ret
